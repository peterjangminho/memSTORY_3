# memSTORY 개발계획서 (한국어)

## 📋 프로젝트 개요

### 프로젝트명: memSTORY
**목표**: 개인화된 온디바이스 LLM 기반 Second Brain 안드로이드 앱

### 핵심 목표
1. **개인화된 AI**: 유저 개인 데이터로 학습된 온디바이스 LLM
2. **VoiceChat 극대화**: 유저의 앱 체류시간 최대화를 위한 자연스러운 음성 대화
3. **완전 오프라인**: 최초 다운로드 후 인터넷 연결 불필요
4. **프라이버시 보장**: 개인 데이터가 외부로 전송되지 않음

### 최종 비전
온디바이스 LLM이 생성한 최적화된 프롬프트로 Universal LLM과 효과적 소통

---

## ⚠️ 이전 실패 요인 분석 및 대응 전략

### 주요 실패 요인들
1. **복잡한 기능의 동시 개발** → **단계적 개발로 전환**
2. **온디바이스 LLM 통합의 기술적 어려움** → **위험도 우선 검증**
3. **과도한 아키텍처 복잡성** → **최소 기능부터 점진 확장**
4. **안드로이드 특화 기술 부족** → **기본기부터 탄탄히 구축**

### 성공을 위한 핵심 전략
- **Walking Skeleton**: 가장 단순한 End-to-End 기능부터 구현
- **위험도 우선**: 가장 어려운 부분(LLM)을 먼저 검증
- **독립 모듈**: 각 컴포넌트를 독립적으로 테스트 가능하게 구성
- **APK 검증**: 각 단계마다 실제 디바이스에서 동작 확인

---

## 🏗️ 시스템 아키텍처

### 기술 스택

#### Core Technologies
- **플랫폼**: Android (Kotlin)
- **UI**: Jetpack Compose
- **의존성 주입**: Koin + KSP
- **아키텍처**: Clean Architecture (Presentation-Domain-Data)

#### AI & ML Stack
- **온디바이스 LLM**: 호환 가능한 LLM 모델 (양자화 최적화)
- **STT**: Vosk (vosk-model-small-en-us-zamia-0.5)
- **TTS**: Piper (en_US-lessac-medium)
- **음성처리**: WebRTC (VAD + AEC + NS)
- **감정인식**: VADER

#### Memory & RAG System
- **임베딩 모델**: 경량 임베딩 솔루션
- **벡터 저장**: SQLite + 벡터 기능
- **메모리 관리**: 커스텀 RAG 시스템

#### Security
- **암호화**: Android KeyStore + AES-256 + Argon2
- **데이터 보호**: 앱 내부 전용 암호화 저장소

### 시스템 아키텍처 다이어그램

```
┌─────────────────────────────────────────────┐
│                Presentation Layer            │
│  ┌─────────────┬─────────────┬─────────────┐ │
│  │ VoiceChat   │ TextChat    │ Settings    │ │
│  │ UI          │ UI          │ UI          │ │
│  └─────────────┴─────────────┴─────────────┘ │
└─────────────────────────────────────────────┘
┌─────────────────────────────────────────────┐
│                Domain Layer                  │
│  ┌─────────────┬─────────────┬─────────────┐ │
│  │ VoiceChat   │ Memory      │ LLM         │ │
│  │ UseCase     │ UseCase     │ UseCase     │ │
│  └─────────────┴─────────────┴─────────────┘ │
└─────────────────────────────────────────────┘
┌─────────────────────────────────────────────┐
│                Data Layer                    │
│  ┌─────────────┬─────────────┬─────────────┐ │
│  │ LLM         │ Voice       │ Memory      │ │
│  │ Repository  │ Repository  │ Repository  │ │
│  └─────────────┴─────────────┴─────────────┘ │
└─────────────────────────────────────────────┘
┌─────────────────────────────────────────────┐
│              Infrastructure Layer            │
│  ┌─────────────┬─────────────┬─────────────┐ │
│  │ LLM         │ WebRTC      │ SQLite +    │ │
│  │ Runtime     │ Pipeline    │ Vector DB   │ │
│  └─────────────┴─────────────┴─────────────┘ │
└─────────────────────────────────────────────┘
```

---

## 📊 위험도 분석 및 완화 전략

### 🔴 HIGH RISK (우선 검증 필요)
1. **온디바이스 LLM 통합**
   - 위험: 메모리 부족, 성능 저하, 배터리 소모
   - 완화: 작은 모델부터 시작, 양자화 적용, 메모리 최적화

2. **실시간 음성처리**
   - 위험: 레이턴시, 음질 저하, 끊김 현상
   - 완화: WebRTC 검증, 버퍼링 최적화, 단계적 구현

### 🟡 MEDIUM RISK
3. **RAG 메모리 시스템**
   - 위험: 검색 정확도, 저장 공간, 성능
   - 완화: 단순한 구조부터 시작, 점진적 개선

4. **사용자 권한 관리**
   - 위험: 권한 거부, 앱 기능 제한
   - 완화: 권한별 대체 시나리오 준비

### 🟢 LOW RISK
5. **UI/UX 구현**
   - 위험: 사용성 문제
   - 완화: 단순한 디자인부터 시작

---

## 🚀 단계별 개발 로드맵

### Phase 0: Foundation & LLM Verification (Week 1-2)
**목표**: 기본 프로젝트 구조 + 온디바이스 LLM 최소 검증

#### Milestones:
- [ ] M0.1: 안드로이드 프로젝트 셋업
- [ ] M0.2: 기본 Compose UI 구조 생성
- [ ] M0.3: Koin DI 설정
- [ ] M0.4: ONNX Runtime 통합
- [ ] M0.5: 최소 LLM 모델 로딩 테스트
- [ ] M0.6: "Hello World" 텍스트 생성 검증
- [ ] M0.7: APK 빌드 및 실제 디바이스 테스트

#### 상세 To-Do:
**T0.1: 프로젝트 셋업**
- [ ] Android Studio 프로젝트 생성 (API 26+)
- [ ] Gradle 설정 (Kotlin, Compose, Koin)
- [ ] 기본 패키지 구조 생성
- [ ] Git 초기화 및 .gitignore 설정

**T0.2: UI 기반 구조**
- [ ] MainActivity + Compose 셋업
- [ ] Navigation Component 설정
- [ ] 기본 테마 및 색상 정의 (파스텔 톤)
- [ ] 간단한 "Hello World" 화면

**T0.3: 의존성 주입**
- [ ] Koin 모듈 구조 설계
- [ ] AppModule, DataModule 기본 설정
- [ ] Application 클래스 설정

**T0.4: LLM 런타임 통합**
- [ ] 적절한 LLM 런타임 라이브러리 추가
- [ ] 테스트용 모델 다운로드 및 준비
- [ ] assets 폴더에 모델 파일 배치
- [ ] 모델 로딩 기본 코드 작성

**T0.5: LLM 추론 엔진**
- [ ] LLM 추론 엔진 클래스 생성
- [ ] 토크나이저 통합
- [ ] 기본 텍스트 생성 함수 구현
- [ ] 메모리 관리 기본 구현

**T0.6: 검증 및 테스트**
- [ ] 단위 테스트 작성
- [ ] "Hello World" 생성 테스트
- [ ] APK 빌드 스크립트 생성
- [ ] 실제 디바이스에서 동작 확인

**성공 기준**: 
- APK가 정상 빌드됨
- 실제 디바이스에서 LLM이 "Hello World" 텍스트 생성
- 메모리 사용량이 허용 범위 이내

---

### Phase 1: Core LLM Integration & TextChat (Week 3-4)
**목표**: 완전한 LLM 통합 및 기본 TextChat 구현

#### Milestones:
- [ ] M1.1: LLM 로딩 최적화 (lazy loading, 메모리 맵핑)
- [ ] M1.2: 컨텍스트 윈도우 관리 구현
- [ ] M1.3: TextChat UI 구현 (WhatsApp 스타일)
- [ ] M1.4: 대화 히스토리 저장/로드
- [ ] M1.5: 성능 최적화 (배치 크기, GPU 가속)
- [ ] M1.6: APK 빌드 및 성능 검증

#### 상세 To-Do:
**T1.1: LLM 엔진 최적화**
- [ ] Lazy loading 구현
- [ ] 메모리 맵핑 적용
- [ ] 모델 언로딩/리로딩 로직
- [ ] 컨텍스트 윈도우 관리 (4K tokens)
- [ ] 토큰 카운팅 시스템

**T1.2: TextChat UI**
- [ ] ChatScreen Compose 구현
- [ ] Message 데이터 클래스 정의
- [ ] RecyclerView 대신 LazyColumn 사용
- [ ] 사용자/AI 메시지 구분 UI
- [ ] 입력창 및 전송 버튼

**T1.3: 대화 로직**
- [ ] ChatRepository 구현
- [ ] 대화 세션 관리
- [ ] 메시지 히스토리 SQLite 저장
- [ ] 컨텍스트 유지 로직

**T1.4: 성능 최적화**
- [ ] 하드웨어 가속 설정 (가능한 경우)
- [ ] CPU 최적화
- [ ] 배치 크기 최적화
- [ ] 백그라운드 스레드 처리

**성공 기준**:
- 연속 대화가 가능한 TextChat 완성
- 응답 시간 3초 이내
- 앱 크래시 없이 30분간 연속 사용 가능

---

### Phase 2: Voice Processing Pipeline (Week 5-6)
**목표**: STT, TTS, 음성처리 파이프라인 구현

#### Milestones:
- [ ] M2.1: Vosk STT 통합
- [ ] M2.2: Piper TTS 통합  
- [ ] M2.3: WebRTC 음성처리 (VAD, AEC, NS)
- [ ] M2.4: 오디오 녹음/재생 관리
- [ ] M2.5: 권한 관리 (마이크, 저장소)
- [ ] M2.6: 기본 음성 입출력 테스트

#### 상세 To-Do:
**T2.1: STT 시스템**
- [ ] Vosk Android 라이브러리 통합
- [ ] vosk-model-small-en-us-zamia-0.5 모델 assets 추가
- [ ] VoskSTTEngine 클래스 구현
- [ ] 실시간 음성 인식 구현
- [ ] 인식 결과 콜백 시스템

**T2.2: TTS 시스템**
- [ ] Piper 바이너리 및 모델 통합
- [ ] PiperTTSEngine 클래스 구현
- [ ] 텍스트 → 음성 변환 구현
- [ ] 오디오 재생 관리

**T2.3: WebRTC 음성처리**
- [ ] WebRTC 라이브러리 통합
- [ ] VAD (Voice Activity Detection) 구현
- [ ] AEC (Acoustic Echo Cancellation) 구현
- [ ] NS (Noise Suppression) 구현
- [ ] 실시간 오디오 처리 파이프라인

**T2.4: 오디오 시스템**
- [ ] AudioRecord 관리
- [ ] AudioTrack 관리
- [ ] 오디오 포맷 최적화 (16kHz, 16-bit)
- [ ] 버퍼링 및 레이턴시 최적화

**T2.5: 권한 관리**
- [ ] 마이크 권한 요청
- [ ] 권한 거부 시 대체 플로우
- [ ] 권한 상태 모니터링

**성공 기준**:
- 음성 → 텍스트 → 음성 변환이 3초 이내 완료
- 음질이 명확히 들림 (잡음 제거 효과 확인)
- 연속 음성 처리 시 메모리 누수 없음

---

### Phase 3: VoiceChat Engine Implementation (Week 7-8)
**목표**: 대화 상태 머신 및 VoiceChat 로직 구현

#### Milestones:
- [ ] M3.1: 대화 상태 머신 설계 및 구현
- [ ] M3.2: 감정 인식 시스템 통합
- [ ] M3.3: 사용자 끼어들기 로직 구현
- [ ] M3.4: VoiceChat UI 구현 (원형 + 파동 효과)
- [ ] M3.5: 대화 단계별 프롬프트 시스템
- [ ] M3.6: 완전한 VoiceChat 플로우 테스트

#### 상세 To-Do:
**T3.1: 대화 상태 머신**
- [ ] ConversationState 열거형 정의
- [ ] 상태 전환 로직 구현
  - 입열기 → 감정확장 → 자유발화 → 정적 → 재자극
- [ ] 타이머 기반 상태 전환
- [ ] 사용자 이벤트 기반 상태 전환

**T3.2: 감정 인식 시스템**
- [ ] VADER 감정 분석 라이브러리 통합
- [ ] 음성 텍스트의 감정 점수 계산
- [ ] 감정 기반 응답 생성 로직
- [ ] 감정 히스토리 추적

**T3.3: 사용자 끼어들기**
- [ ] TTS 재생 중 VAD 모니터링
- [ ] AEC로 TTS 음성 제거 후 사용자 음성 감지
- [ ] 끼어들기 감지 시 TTS 즉시 중단
- [ ] STT 모드로 자동 전환

**T3.4: VoiceChat UI**
- [ ] 중앙 원형 버튼 UI (Compose)
- [ ] 음성 인식 시 파동 애니메이션
- [ ] 하단 대화 텍스트 표시 (3줄 제한)
- [ ] 대화 상태 시각적 표시

**T3.5: 프롬프트 시스템**
- [ ] 입열기용 시스템 프롬프트 (200 토큰 이내)
- [ ] 감정확장용 프롬프트 생성
- [ ] Narrowing Principle 적용 로직
- [ ] 재자극용 질문 생성 (Question A/B)

**T3.6: 호응 시스템**
- [ ] "do you?", "really?" 등 짧은 호응 구현
- [ ] 2~3문장 후 적절한 타이밍 호응
- [ ] 1분 이상 대화 시 요약형 호응
- [ ] User Interruption 미적용 호응

**성공 기준**:
- 완전한 대화 사이클이 자연스럽게 진행
- 사용자 끼어들기가 즉시 반응 (1초 이내)
- 감정에 따른 적절한 응답 생성
- 30분간 끊김없는 대화 가능

---

### Phase 4: Memory Generation Engine (Week 9-10)
**목표**: RAG 기반 메모리 생성 및 관리 시스템

#### Milestones:
- [ ] M4.1: 임베딩 시스템 구현
- [ ] M4.2: 벡터 데이터베이스 구축
- [ ] M4.3: 유휴시간 #1 - 캘린더/메모 데이터 수집
- [ ] M4.4: 유휴시간 #2 - All-inData 생성
- [ ] M4.5: Keyinfo mark 시스템
- [ ] M4.6: 메모리 검색 및 컨텍스트 생성

#### 상세 To-Do:
**T4.1: 임베딩 시스템**
- [ ] 경량 임베딩 모델 구현
- [ ] EmbeddingEngine 클래스 구현
- [ ] 텍스트 → 벡터 변환 기능
- [ ] 유사도 계산 함수

**T4.2: 벡터 데이터베이스**
- [ ] SQLite + 벡터 기능 설정
- [ ] 벡터 저장 스키마 설계
- [ ] VectorRepository 클래스 구현
- [ ] 유사도 검색 쿼리 최적화

**T4.3: 데이터 수집 시스템**
- [ ] 캘린더 앱 접근 권한
- [ ] CalendarDataCollector 구현
- [ ] 메모 앱 데이터 읽기 (가능한 경우)
- [ ] 날짜별 데이터 구조화

**T4.4: All-inData 생성**
- [ ] 데이터 그룹핑 알고리즘
- [ ] 주제별 클러스터링
- [ ] 요약 생성 (LLM 활용)
- [ ] 시간 기반 가중치 적용

**T4.5: Keyinfo Mark**
- [ ] 대화 시간 추적
- [ ] 중요도 점수 계산
- [ ] Keyinfo 마킹 로직
- [ ] 우선순위 정렬 시스템

**T4.6: 백그라운드 처리**
- [ ] WorkManager를 이용한 유휴시간 스케줄링
- [ ] 새벽 2-3시 자동 실행
- [ ] 배터리 최적화 예외 처리
- [ ] 진행 상황 알림

**성공 기준**:
- 캘린더 데이터가 정상적으로 수집됨
- All-inData가 의미있게 그룹핑됨
- 백그라운드에서 안정적으로 실행
- 메모리 사용량이 합리적 수준

---

### Phase 5: Settings & Data Management (Week 11)
**목표**: 설정 페이지 및 데이터 관리 기능

#### Milestones:
- [ ] M5.1: 설정 페이지 UI 구현
- [ ] M5.2: 권한 관리 인터페이스
- [ ] M5.3: 데이터 백업/복원 기능
- [ ] M5.4: LLM 모델 관리
- [ ] M5.5: 수동 학습 기능

#### 상세 To-Do:
**T5.1: 설정 UI**
- [ ] SettingsScreen Compose 구현
- [ ] 카테고리별 설정 그룹핑
- [ ] 토글, 버튼, 슬라이더 컴포넌트
- [ ] 우측 상단 아이콘에서 접근

**T5.2: 권한 관리**
- [ ] 각 권한별 상태 표시
- [ ] 수동 권한 요청 기능
- [ ] 권한 설명 다이얼로그
- [ ] 시스템 설정으로 이동 링크

**T5.3: 데이터 백업**
- [ ] 암호화된 백업 파일 생성
- [ ] 외부 저장소 접근
- [ ] 백업 진행률 표시
- [ ] 백업 완료 알림

**T5.4: 데이터 복원**
- [ ] 백업 파일 검증
- [ ] 사용자 비밀번호 인증
- [ ] 데이터 복원 프로세스
- [ ] 복원 후 재시작

**성공 기준**:
- 모든 설정 항목이 정상 작동
- 백업/복원이 오류없이 완료
- 사용자 친화적 인터페이스

---

### Phase 6: Security & Encryption (Week 12)
**목표**: 암호화 시스템 및 보안 강화

#### Milestones:
- [ ] M6.1: Android KeyStore 기반 키 관리
- [ ] M6.2: AES-256 + Argon2 암호화 시스템
- [ ] M6.3: 모든 민감 데이터 암호화
- [ ] M6.4: 앱 외부 파일 보안
- [ ] M6.5: 디바이스 변경 시나리오 테스트

#### 상세 To-Do:
**T6.1: 키 관리 시스템**
- [ ] Android KeyStore 키 생성
- [ ] 하드웨어 보안 키 활용
- [ ] 키 순환 정책 구현
- [ ] 키 백업/복구 전략

**T6.2: 암호화 시스템**
- [ ] AES-256-GCM 구현
- [ ] Argon2 사용자 키 도출
- [ ] PBKDF2 추가 보안 레이어
- [ ] 무결성 검증 시스템

**T6.3: 데이터 보호**
- [ ] VoicechatData 암호화
- [ ] CalMemoData 암호화
- [ ] LLM 모델 파일 보호
- [ ] All-inData 보안 저장

**성공 기준**:
- 모든 민감 데이터가 암호화되어 저장
- 앱 외부에서 파일 열기 불가
- 디바이스 변경 시 정상 복원

---

### Phase 7: Performance & Optimization (Week 13)
**목표**: 성능 최적화 및 안정성 향상

#### Milestones:
- [ ] M7.1: 메모리 사용량 최적화
- [ ] M7.2: 배터리 소모 최소화
- [ ] M7.3: 응답 속도 개선
- [ ] M7.4: 앱 시작 시간 단축
- [ ] M7.5: 안정성 테스트

#### 상세 To-Do:
**T7.1: 메모리 최적화**
- [ ] 메모리 프로파일링
- [ ] 메모리 리크 제거
- [ ] LLM 모델 효율적 로딩
- [ ] 캐시 시스템 구현

**T7.2: 성능 튜닝**
- [ ] CPU 사용률 최적화
- [ ] 하드웨어 가속 활용
- [ ] I/O 작업 비동기 처리
- [ ] 리소스 사용량 최소화

**성공 기준**:
- 메모리 사용량 허용 범위 이내
- 앱 시작 시간 5초 이내
- 24시간 연속 실행 가능

---

### Phase 8: UI/UX Polish & Final Testing (Week 14-15)
**목표**: UI 개선 및 최종 테스트

#### Milestones:
- [ ] M8.1: UI 디자인 완성도 향상
- [ ] M8.2: 사용자 경험 개선
- [ ] M8.3: 접근성 기능 추가
- [ ] M8.4: 종합 테스트
- [ ] M8.5: 최종 APK 빌드

#### 상세 To-Do:
**T8.1: UI 폴리싱**
- [ ] 파스텔 톤 테마 완성
- [ ] 애니메이션 및 전환 효과
- [ ] 아이콘 디자인 개선
- [ ] 레이아웃 반응형 최적화

**T8.2: UX 개선**
- [ ] 사용자 온보딩 플로우
- [ ] 도움말 및 튜토리얼
- [ ] 에러 처리 개선
- [ ] 피드백 시스템

**T8.3: 테스팅**
- [ ] 단위 테스트 완성
- [ ] 통합 테스트 실행
- [ ] 실제 디바이스 다양성 테스트
- [ ] 성능 벤치마크

**성공 기준**:
- 모든 기능이 안정적으로 동작
- 사용자 친화적 인터페이스 완성
- 배포 가능한 품질 달성

---

## 📈 성공 지표 및 검증 기준

### 기술적 성공 지표
- **LLM 성능**: 응답 시간 3초 이내, 메모리 사용량 합리적 수준
- **음성 처리**: STT 정확도 90% 이상, TTS 자연스러움 확보
- **안정성**: 24시간 연속 실행, 크래시율 1% 이하
- **사용성**: 앱 시작 시간 5초 이내, 직관적 UI/UX

### 비즈니스 성공 지표
- **사용자 체류시간**: 평균 30분 이상 연속 대화
- **개인화 품질**: 사용자별 맞춤 응답 정확도
- **오프라인 완성도**: 인터넷 없이 모든 기능 정상 동작

---

## 🎯 각 Phase별 리스크 관리

### 위험 시나리오 및 대응책
1. **LLM 성능 부족** → 최적화된 모델로 대체, 양자화 강화
2. **메모리 부족** → 효율적인 로딩, 메모리 사용량 최적화
3. **음성 처리 품질 저하** → 파라미터 튜닝, 대체 라이브러리 검토
4. **개발 일정 지연** → 기능 우선순위 재조정, MVP 범위 축소

### 단계별 검증 포인트
각 Phase 완료 시 반드시 다음 항목들을 확인:
- [ ] APK 빌드 성공
- [ ] 실제 디바이스에서 기능 동작
- [ ] 메모리 사용량 임계치 이내
- [ ] 사용자 시나리오 테스트 통과

---

## 📝 개발 진행 관리

### 체크리스트 기반 관리
- 각 To-Do 항목별 체크박스로 진행상황 추적
- 주간 단위 진도 검토 및 조정
- 월간 단위 Milestone 달성 평가

### 문서화 규칙
- Phase 완료 시마다 한국어 MD 파일 생성
- 기술적 이슈 및 해결책 기록
- 성능 벤치마크 결과 보관

---

이 계획서는 이전 10번의 실패를 바탕으로, 가장 현실적이고 단계적인 접근법을 제시합니다. 각 Phase에서 실제 동작하는 결과물을 확인하며 점진적으로 발전시켜 나가는 것이 성공의 핵심입니다.